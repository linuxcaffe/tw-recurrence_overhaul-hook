#!/usr/bin/env python3
"""
Taskwarrior Enhanced Recurrence Hook - On-Exit
Spawns new recurrence instances when needed

Version: 0.7.0
Date: 2026-01-15
Changes: Write instances directly to pending.data instead of subprocess to avoid get_changes() issue


Installation:
    Save to ~/.task/hooks/on-exit_recurrence.py
    chmod +x ~/.task/hooks/on-exit_recurrence.py
"""

import sys
import json
import subprocess
from datetime import datetime, timedelta
import re
import os
import uuid

VERSION = "0.7.0"

# ============================================================================
# Task Version Check
# ============================================================================

def check_task_version():
    """
    Verify Taskwarrior version is 2.x
    This hook system is designed for Taskwarrior 2.6.x
    For Taskwarrior 3.x (Taskchampion) compatibility, see DEVELOPERS.md
    """
    try:
        result = subprocess.run(
            ['task', '--version'],
            capture_output=True,
            text=True,
            timeout=2
        )
        version_line = result.stdout.strip()
        # Extract version number (format: "2.6.2" or "3.0.0")
        match = re.search(r'(\d+)\.(\d+)\.(\d+)', version_line)
        if match:
            major = int(match.group(1))
            if major >= 3:
                sys.stderr.write("\n" + "="*70 + "\n")
                sys.stderr.write("ERROR: Taskwarrior 3.x (Taskchampion) detected!\n")
                sys.stderr.write("\nThis recurrence hook system is designed for Taskwarrior 2.x\n")
                sys.stderr.write("and has not been tested with Taskwarrior 3.x.\n\n")
                sys.stderr.write("For information about 3.x compatibility, see:\n")
                sys.stderr.write("  ~/.task/hooks/recurrence/recurrence_DEVELOPERS.md\n\n")
                sys.stderr.write("If you would like to help port this to Taskwarrior 3.x,\n")
                sys.stderr.write("please submit a PR with documented changes and passing tests.\n")
                sys.stderr.write("="*70 + "\n\n")
                sys.exit(1)
    except Exception as e:
        # If version check fails, log it but don't block (maybe task isn't in PATH)
        sys.stderr.write(f"Warning: Could not verify task version: {e}\n")

# Check version at module load - DISABLED for development
# check_task_version()

# ============================================================================
# Configuration Detection
# ============================================================================

def get_task_config():
    """
    Detect task configuration from multiple sources (priority order):
    1. Environment variables (TASKRC, TASKDATA) - set by test scripts
    2. Config exports (export.RECURRENCE_RC, export.RECURRENCE_DATA) - set in taskrc
    3. Fallback to defaults (~/.taskrc, ~/.task)
    
    Returns: (taskrc_path, data_location, task_base_cmd)
    """
    taskrc = os.environ.get('TASKRC')
    taskdata = os.environ.get('TASKDATA')
    
    # Try to read from taskwarrior config if not in environment
    if not taskrc or not taskdata:
        try:
            result = subprocess.run(
                ['task', 'rc.verbose=nothing', '_get', 'rc.data.location'],
                capture_output=True,
                text=True,
                timeout=2
            )
            if result.returncode == 0 and result.stdout.strip():
                taskdata = result.stdout.strip()
        except:
            pass
    
    # Fallback to defaults
    if not taskrc:
        taskrc = os.path.expanduser("~/.taskrc")
    if not taskdata:
        taskdata = os.path.expanduser("~/.task")
    
    # Build base task command with explicit config
    task_base_cmd = ['task']
    if taskrc and os.path.exists(taskrc):
        task_base_cmd.extend(['rc:' + taskrc])
    if taskdata:
        task_base_cmd.extend(['rc.data.location=' + taskdata])
    
    return taskrc, taskdata, task_base_cmd

# Configuration will be loaded lazily
_config_cache = None

def get_config():
    """Get or initialize configuration (lazy loading)"""
    global _config_cache
    if _config_cache is None:
        _config_cache = get_task_config()
    return _config_cache

# Optional debug mode
DEBUG = os.environ.get('DEBUG_RECURRENCE', '0') == '1'

def get_log_file():
    """Get log file path based on current configuration"""
    _, taskdata, _ = get_config()
    if taskdata:
        return os.path.join(taskdata, "recurrence_debug.log")
    else:
        return os.path.expanduser("~/.task/recurrence_debug.log")

def debug_log(msg):
    """Write debug message to log file if debug enabled"""
    if DEBUG:
        try:
            log_file = get_log_file()
            os.makedirs(os.path.dirname(log_file), exist_ok=True)
            with open(log_file, 'a') as f:
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                f.write(f"[{timestamp}] EXIT: {msg}\n")
        except Exception as e:
            # Fallback to stderr if logging fails
            print(f"[DEBUG-EXIT] {msg}", file=sys.stderr)
            print(f"[DEBUG-EXIT] Error: {e}", file=sys.stderr)

if DEBUG:
    debug_log("="*60)
    debug_log("on-exit hook started")
    taskrc, taskdata, task_base_cmd = get_config()
    debug_log(f"TASKRC: {taskrc}")
    debug_log(f"TASKDATA: {taskdata}")
    debug_log(f"LOG_FILE: {get_log_file()}")
    debug_log(f"Task base command: {' '.join(task_base_cmd)}")


class RecurrenceSpawner:
    """Spawns new recurrence instances"""
    
    def __init__(self):
        self.now = datetime.utcnow()
    
    def parse_duration(self, duration_str):
        """Parse duration string to timedelta"""
        if not duration_str:
            return None
        
        # Simple formats
        match = re.match(r'(\d+)(s|d|w|mo|y)', str(duration_str).lower())
        if match:
            num, unit = match.groups()
            num = int(num)
            if unit == 's':
                return timedelta(seconds=num)
            elif unit == 'd':
                return timedelta(days=num)
            elif unit == 'w':
                return timedelta(weeks=num)
            elif unit == 'mo':
                return timedelta(days=num * 30)
            elif unit == 'y':
                return timedelta(days=num * 365)
        
        # ISO 8601
        pattern = r'P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?'
        match = re.match(pattern, str(duration_str))
        if match:
            years, months, weeks, days, hours, mins, secs = match.groups()
            delta = timedelta()
            if secs:
                delta += timedelta(seconds=int(secs))
            if mins:
                delta += timedelta(minutes=int(mins))
            if hours:
                delta += timedelta(hours=int(hours))
            if days:
                delta += timedelta(days=int(days))
            if weeks:
                delta += timedelta(weeks=int(weeks))
            if months:
                delta += timedelta(days=int(months) * 30)
            if years:
                delta += timedelta(days=int(years) * 365)
            return delta
        
        return None
    
    def parse_date(self, date_str):
        """Parse ISO 8601 date"""
        if not date_str:
            return None
        try:
            clean = str(date_str).replace('Z', '').replace('+00:00', '')
            return datetime.strptime(clean[:15], '%Y%m%dT%H%M%S')
        except (ValueError, AttributeError):
            return None
    
    def format_date(self, dt):
        """Format datetime as ISO 8601"""
        return dt.strftime('%Y%m%dT%H%M%SZ')
    
    def parse_relative_date(self, rel_str, anchor_date):
        """Parse relative date like 'due-2d' given anchor date"""
        if not rel_str or not anchor_date:
            return None
        
        match = re.match(r'(due|scheduled|wait)\s*([+-])\s*(\d+)(s|d|w|mo|y)', 
                        str(rel_str).lower())
        if match:
            ref_field, sign, num, unit = match.groups()
            num = int(num)
            
            if unit == 's':
                delta = timedelta(seconds=num)
            elif unit == 'd':
                delta = timedelta(days=num)
            elif unit == 'w':
                delta = timedelta(weeks=num)
            elif unit == 'mo':
                delta = timedelta(days=num * 30)
            elif unit == 'y':
                delta = timedelta(days=num * 365)
            else:
                return None
            
            if sign == '-':
                delta = -delta
            
            return anchor_date + delta
        
        return None
    
    def get_template(self, uuid):
        """Fetch template task by UUID"""
        try:
            _, _, task_base_cmd = get_config()
            cmd = task_base_cmd + ['rc.hooks=off', uuid, 'export']
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=True
            )
            lines = [line for line in result.stdout.strip().split('\n') if line]
            if lines:
                return json.loads(lines[0])
        except Exception as e:
            if DEBUG:
                debug_log(f"Error fetching template {uuid}: {e}")
        return None
    
    def check_rend(self, template, new_date):
        """Check if new_date exceeds recurrence end date (rend)"""
        if 'rend' not in template:
            return False
        
        rend_str = template['rend']
        anchor_field = template.get('ranchor', 'due')
        anchor_date = self.parse_date(template.get(anchor_field))
        rend_date = self.parse_relative_date(rend_str, anchor_date)
        
        if not rend_date:
            rend_date = self.parse_date(rend_str)
        
        if rend_date and new_date > rend_date:
            return True
        
        return False
    
    def get_pending_instances(self, template_uuid):
        """Get all pending instances for a template"""
        try:
            _, _, task_base_cmd = get_config()
            cmd = task_base_cmd + ['rc.hooks=off', f'rtemplate:{template_uuid}', 'status:pending', 'export']
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=True
            )
            lines = [line for line in result.stdout.strip().split('\n') if line]
            instances = [json.loads(line) for line in lines if line]
            return instances
        except Exception as e:
            if DEBUG:
                debug_log(f"Error fetching pending instances for {template_uuid}: {e}")
        return []
    
    def format_task_ids(self, tasks):
        """Format list of tasks as comma-separated IDs"""
        ids = [str(task.get('id', task.get('uuid', ''))) for task in tasks]
        return ','.join(filter(None, ids))
    
    def create_instance(self, template, index, completion_time=None):
        """Create a new instance task by writing directly to pending.data"""
        if DEBUG:
            debug_log(f"Creating instance {index} from {template.get('uuid')}")
        
        recur_delta = self.parse_duration(template.get('r'))
        if not recur_delta:
            return None
        
        rtype = template.get('type', 'periodic')
        anchor_field = template.get('ranchor', 'due')
        
        # Calculate anchor date
        if rtype == 'chained':
            base = completion_time or self.now
            anchor_date = base + recur_delta
        else:  # periodic
            template_anchor = self.parse_date(template.get(anchor_field))
            if not template_anchor:
                return None
            
            # Find next occurrence after now
            idx = index
            anchor_date = template_anchor + (recur_delta * idx)
            while anchor_date < self.now:
                idx += 1
                anchor_date = template_anchor + (recur_delta * idx)
            index = idx
        
        # Check rend date
        if self.check_rend(template, anchor_date):
            return "Recurrence ended (rend date reached)"
        
        # Build new instance task as JSON object
        import uuid
        instance = {
            'description': template['description'],
            'entry': self.format_date(self.now),
            'status': 'pending',
            'uuid': str(uuid.uuid4()),
            anchor_field: self.format_date(anchor_date),
            'rtemplate': template['uuid'],
            'rindex': index
        }
        
        # Copy until from template if present
        if 'until' in template:
            instance['until'] = template['until']
        
        # Process wait
        if 'rwait' in template:
            wait_date = self.parse_relative_date(template['rwait'], anchor_date)
            if wait_date:
                instance['wait'] = self.format_date(wait_date)
                instance['status'] = 'waiting'
        
        # Process scheduled
        if 'rscheduled' in template and anchor_field != 'scheduled':
            sched_date = self.parse_relative_date(template['rscheduled'], anchor_date)
            if sched_date:
                instance['scheduled'] = self.format_date(sched_date)
        
        # Copy attributes
        if 'project' in template:
            instance['project'] = template['project']
        if 'priority' in template:
            instance['priority'] = template['priority']
        if 'tags' in template and template['tags']:
            instance['tags'] = template['tags']
        
        # Write directly to pending.data
        try:
            _, taskdata, _ = get_config()
            pending_file = os.path.join(taskdata, 'pending.data')
            
            # Append the new task as a JSON line
            with open(pending_file, 'a') as f:
                f.write(json.dumps(instance) + '\n')
            
            if DEBUG:
                debug_log(f"Instance {index} written directly to pending.data")
            
            # Update template's rlast - keep hooks off for template modifications
            _, _, task_base_cmd = get_config()
            update_cmd = task_base_cmd + ['rc.hooks=off', f'uuid:{template["uuid"]}', 'modify', f'rlast:{index}']
            subprocess.run(
                update_cmd,
                capture_output=True,
                check=True,
                text=True
            )
            
            if DEBUG:
                debug_log(f"Instance {index} created successfully")
            
            return f"Created instance {index}"
        except Exception as e:
            if DEBUG:
                debug_log(f"Error creating instance: {e}")
                import traceback
                debug_log(f"Traceback: {traceback.format_exc()}")
            return None
    
    def process_tasks(self, tasks):
        """Process tasks and spawn instances"""
        feedback = []
        
        if DEBUG:
            debug_log(f"process_tasks: Processing {len(tasks)} task(s)")
            sys.stderr.write(f"[EXIT DEBUG] Processing {len(tasks)} task(s)\n")
        
        for task in tasks:
            if DEBUG:
                debug_log(f"  Task: {task.get('description', 'NO_DESC')} status={task.get('status')} rtemplate={task.get('rtemplate', 'N/A')} rindex={task.get('rindex', 'N/A')}")
                sys.stderr.write(f"[EXIT DEBUG] Task: desc='{task.get('description', 'NO_DESC')}' status={task.get('status')} rtemplate={task.get('rtemplate', 'N/A')} rindex={task.get('rindex', 'N/A')}\n")
            
            # Completed/deleted instance?
            if (task.get('status') in ['completed', 'deleted'] and 
                'rtemplate' in task and 'rindex' in task):
                
                if DEBUG:
                    debug_log(f"  -> Detected completed/deleted instance")
                    sys.stderr.write(f"[EXIT DEBUG] -> Detected completed/deleted INSTANCE!\n")
                
                template = self.get_template(task['rtemplate'])
                if not template:
                    if DEBUG:
                        debug_log(f"  -> Template not found: {task['rtemplate']}")
                    continue
                
                current_idx = int(task['rindex'])
                last_idx = int(template.get('rlast', '0'))
                
                if DEBUG:
                    debug_log(f"  -> current_idx={current_idx}, last_idx={last_idx}")
                
                # Message for deleted instance
                if task.get('status') == 'deleted':
                    template_id = template.get('id', template.get('uuid'))
                    feedback.append(
                        f"This is a recurring task. To delete all future instances "
                        f"enter 'task {template_id} delete'"
                    )
                
                # Only spawn if this is the latest instance
                if current_idx >= last_idx:
                    if DEBUG:
                        debug_log(f"  -> Spawning next instance (index {current_idx + 1})")
                        sys.stderr.write(f"[EXIT DEBUG] -> Spawning instance {current_idx + 1}!\n")
                    
                    completion = None
                    if task.get('status') == 'completed' and 'end' in task:
                        completion = self.parse_date(task['end'])
                    
                    msg = self.create_instance(template, current_idx + 1, completion)
                    if msg:
                        feedback.append(msg)
                        if DEBUG:
                            sys.stderr.write(f"[EXIT DEBUG] -> Instance created: {msg}\n")
                else:
                    if DEBUG:
                        debug_log(f"  -> NOT spawning (not latest instance)")
                        sys.stderr.write(f"[EXIT DEBUG] -> NOT spawning (not latest: {current_idx} < {last_idx})\n")
            
            # Completed/deleted template?
            # A template has 'r' and 'rlast' but is NOT an instance (no rtemplate)
            elif (task.get('status') in ['completed', 'deleted'] and 
                  'r' in task and 'rlast' in task and 
                  'rtemplate' not in task):
                
                action = "Completing" if task.get('status') == 'completed' else "Deleting"
                action_cmd = "done" if task.get('status') == 'completed' else "delete"
                
                # Get pending instances
                template_uuid = task.get('uuid')
                pending = self.get_pending_instances(template_uuid)
                
                if pending:
                    ids = self.format_task_ids(pending)
                    feedback.append(
                        f"This is a recurrence template. {action} it will stop all future instances. "
                        f"To {action_cmd} any pending instances enter 'task {ids} {action_cmd}'"
                    )
                else:
                    feedback.append(
                        f"This is a recurrence template. {action} it will stop all future instances."
                    )
            
            # New template? (handle both string and int rlast)
            elif (task.get('status') == 'recurring' and 
                  'r' in task and 
                  str(task.get('rlast', '')).strip() in ['0', '']):
                
                if DEBUG:
                    debug_log(f"Found new template: {task.get('description')}")
                
                msg = self.create_instance(task, 1)
                if msg:
                    feedback.append(msg)
        
        return feedback


def main():
    """Main entry point for on-exit"""
    lines = sys.stdin.readlines()
    
    if DEBUG:
        debug_log(f"on-exit stdin received {len(lines)} lines")
        if lines:
            debug_log(f"First line sample: {lines[0][:100] if lines[0] else '(empty)'}")
    
    if not lines:
        if DEBUG:
            debug_log("No input received, exiting normally")
        sys.exit(0)
    
    try:
        tasks = [json.loads(line) for line in lines if line.strip()]
        if DEBUG:
            debug_log(f"Parsed {len(tasks)} tasks")
            for task in tasks:
                debug_log(f"  Task: {task.get('description', 'NO DESC')} status={task.get('status', 'NO STATUS')}")
    except json.JSONDecodeError as e:
        if DEBUG:
            debug_log(f"JSON decode error: {e}")
        sys.exit(0)
    
    spawner = RecurrenceSpawner()
    feedback = spawner.process_tasks(tasks)
    
    for msg in feedback:
        print(msg)
    
    if DEBUG:
        debug_log("on-exit completed")
    
    sys.exit(0)


if __name__ == '__main__':
    main()
