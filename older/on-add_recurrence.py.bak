#!/usr/bin/env python3
"""
Taskwarrior Enhanced Recurrence Hook - On-Add/On-Modify
Handles both adding new recurring tasks and modifying existing ones

Version: 0.5.10
Date: 2026-01-15
Changes: CRITICAL FIX - corrected print statement indentation (was inside elif block)


Installation:
    1. Save to ~/.task/hooks/on-add_recurrence.py
    2. chmod +x ~/.task/hooks/on-add_recurrence.py
    3. cd ~/.task/hooks && ln -s on-add_recurrence.py on-modify_recurrence.py
"""

import sys
import json
from datetime import datetime, timedelta
import re
import os
import subprocess

VERSION = "0.5.10"

# ============================================================================
# Task Version Check
# ============================================================================

def check_task_version():
    """
    Verify Taskwarrior version is 2.x
    This hook system is designed for Taskwarrior 2.6.x
    For Taskwarrior 3.x (Taskchampion) compatibility, see DEVELOPERS.md
    """
    try:
        result = subprocess.run(
            ['task', '--version'],
            capture_output=True,
            text=True,
            timeout=2
        )
        version_line = result.stdout.strip()
        # Extract version number (format: "2.6.2" or "3.0.0")
        match = re.search(r'(\d+)\.(\d+)\.(\d+)', version_line)
        if match:
            major = int(match.group(1))
            if major >= 3:
                sys.stderr.write("\n" + "="*70 + "\n")
                sys.stderr.write("ERROR: Taskwarrior 3.x (Taskchampion) detected!\n")
                sys.stderr.write("\nThis recurrence hook system is designed for Taskwarrior 2.x\n")
                sys.stderr.write("and has not been tested with Taskwarrior 3.x.\n\n")
                sys.stderr.write("For information about 3.x compatibility, see:\n")
                sys.stderr.write("  ~/.task/hooks/recurrence/recurrence_DEVELOPERS.md\n\n")
                sys.stderr.write("If you would like to help port this to Taskwarrior 3.x,\n")
                sys.stderr.write("please submit a PR with documented changes and passing tests.\n")
                sys.stderr.write("="*70 + "\n\n")
                sys.exit(1)
    except Exception as e:
        # If version check fails, log it but don't block (maybe task isn't in PATH)
        sys.stderr.write(f"Warning: Could not verify task version: {e}\n")

# Check version at module load - DISABLED for development
# check_task_version()

# ============================================================================
# Configuration Detection
# ============================================================================

def get_task_config():
    """
    Detect task configuration from multiple sources (priority order):
    1. Environment variables (TASKRC, TASKDATA) - set by test scripts
    2. Config exports (export.RECURRENCE_RC, export.RECURRENCE_DATA) - set in taskrc
    3. Fallback to defaults (~/.taskrc, ~/.task)
    
    Returns: (taskrc_path, data_location, task_base_cmd)
    """
    taskrc = os.environ.get('TASKRC')
    taskdata = os.environ.get('TASKDATA')
    
    # Try to read from taskwarrior config if not in environment
    if not taskrc or not taskdata:
        try:
            result = subprocess.run(
                ['task', 'rc.verbose=nothing', '_get', 'rc.data.location'],
                capture_output=True,
                text=True,
                timeout=2
            )
            if result.returncode == 0 and result.stdout.strip():
                taskdata = result.stdout.strip()
        except:
            pass
    
    # Fallback to defaults
    if not taskrc:
        taskrc = os.path.expanduser("~/.taskrc")
    if not taskdata:
        taskdata = os.path.expanduser("~/.task")
    
    # Build base task command with explicit config
    task_base_cmd = ['task']
    if taskrc and os.path.exists(taskrc):
        task_base_cmd.extend(['rc:' + taskrc])
    if taskdata:
        task_base_cmd.extend(['rc.data.location=' + taskdata])
    
    return taskrc, taskdata, task_base_cmd

# Configuration will be loaded lazily
_config_cache = None

def get_config():
    """Get or initialize configuration (lazy loading)"""
    global _config_cache
    if _config_cache is None:
        _config_cache = get_task_config()
    return _config_cache

# Optional debug mode
DEBUG = os.environ.get('DEBUG_RECURRENCE', '0') == '1'

def get_log_file():
    """Get log file path based on current configuration"""
    _, taskdata, _ = get_config()
    if taskdata:
        return os.path.join(taskdata, "recurrence_debug.log")
    else:
        return os.path.expanduser("~/.task/recurrence_debug.log")

def debug_log(msg):
    """Write debug message to log file if debug enabled"""
    if DEBUG:
        try:
            log_file = get_log_file()
            os.makedirs(os.path.dirname(log_file), exist_ok=True)
            with open(log_file, 'a') as f:
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                f.write(f"[{timestamp}] ADD/MOD: {msg}\n")
        except Exception as e:
            # Fallback to stderr if logging fails
            print(f"[DEBUG-ADD] {msg}", file=sys.stderr)
            print(f"[DEBUG-ADD] Error: {e}", file=sys.stderr)

if DEBUG:
    debug_log("="*60)
    debug_log("Hook starting")
    taskrc, taskdata, task_base_cmd = get_config()
    debug_log(f"TASKRC: {taskrc}")
    debug_log(f"TASKDATA: {taskdata}")
    debug_log(f"LOG_FILE: {get_log_file()}")

# Read all input
lines = sys.stdin.readlines()
IS_ON_ADD = len(lines) == 1

if DEBUG:
    debug_log(f"Mode: {'ADD' if IS_ON_ADD else 'MODIFY'}, lines: {len(lines)}")


class RecurrenceHandler:
    """Handles enhanced recurrence for Taskwarrior"""
    
    def __init__(self):
        self.now = datetime.utcnow()
    
    def normalize_type(self, type_str):
        """Normalize type abbreviations to full names"""
        if not type_str:
            return 'periodic'
        
        type_lower = str(type_str).lower()
        
        # Handle abbreviations
        if type_lower in ['c', 'ch', 'cha', 'chai', 'chain', 'chained']:
            return 'chained'
        elif type_lower in ['p', 'pe', 'per', 'peri', 'perio', 'period', 'periodic']:
            return 'periodic'
        
        # Default to periodic for unknown
        return 'periodic'
    
    def parse_duration(self, duration_str):
        """Parse duration string (7d, 1w, 1mo, etc.) to timedelta"""
        if not duration_str:
            return None
        
        # Handle simple formats
        match = re.match(r'(\d+)(d|w|mo|y)', str(duration_str).lower())
        if match:
            num, unit = match.groups()
            num = int(num)
            if unit == 'd':
                return timedelta(days=num)
            elif unit == 'w':
                return timedelta(weeks=num)
            elif unit == 'mo':
                return timedelta(days=num * 30)
            elif unit == 'y':
                return timedelta(days=num * 365)
        
        # Handle ISO 8601 duration
        pattern = r'P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?'
        match = re.match(pattern, str(duration_str))
        if match:
            years, months, weeks, days, hours, mins, secs = match.groups()
            delta = timedelta()
            if days:
                delta += timedelta(days=int(days))
            if weeks:
                delta += timedelta(weeks=int(weeks))
            if hours:
                delta += timedelta(hours=int(hours))
            if mins:
                delta += timedelta(minutes=int(mins))
            if secs:
                delta += timedelta(seconds=int(secs))
            if months:
                delta += timedelta(days=int(months) * 30)
            if years:
                delta += timedelta(days=int(years) * 365)
            return delta
        
        return None
    
    def parse_date(self, date_str):
        """Parse ISO 8601 date string"""
        if not date_str:
            return None
        try:
            clean = str(date_str).replace('Z', '').replace('+00:00', '')
            return datetime.strptime(clean[:15], '%Y%m%dT%H%M%S')
        except (ValueError, AttributeError):
            return None
    
    def format_date(self, dt):
        """Format datetime as ISO 8601"""
        return dt.strftime('%Y%m%dT%H%M%SZ')
    
    def parse_relative_date(self, date_str):
        """Parse relative date expression like 'due-2d'"""
        if not date_str:
            return None, None
        
        match = re.match(r'(due|scheduled|wait)\s*([+-])\s*(\d+)(d|w|mo|y)', 
                        str(date_str).lower())
        if match:
            ref_field, sign, num, unit = match.groups()
            num = int(num)
            
            if unit == 'd':
                delta = timedelta(days=num)
            elif unit == 'w':
                delta = timedelta(weeks=num)
            elif unit == 'mo':
                delta = timedelta(days=num * 30)
            elif unit == 'y':
                delta = timedelta(days=num * 365)
            else:
                return None, None
            
            if sign == '-':
                delta = -delta
            
            return ref_field, delta
        
        return None, None
    
    def is_template(self, task):
        """Check if task is a recurrence template"""
        return task.get('status') == 'recurring' and 'r' in task
    
    def is_instance(self, task):
        """Check if task is a recurrence instance"""
        return 'rtemplate' in task and 'rindex' in task
    
    def get_anchor_date(self, task):
        """Get the anchor date (due or scheduled) for recurrence"""
        if 'due' in task:
            return 'due', self.parse_date(task['due'])
        elif 'scheduled' in task:
            return 'scheduled', self.parse_date(task['scheduled'])
        return None, None
    
    def create_template(self, task):
        """Convert a new task with r (recurrence) into a template"""
        if DEBUG:
            debug_log(f"Creating template: {task.get('description')}")
        
        if 'r' not in task:
            return task
        
        # Normalize and set type (with abbreviation support)
        task['type'] = self.normalize_type(task.get('type'))
        
        if DEBUG:
            debug_log(f"  Type: {task['type']}, r={task.get('r')}")
        
        # Mark as template
        task['status'] = 'recurring'
        task['rlast'] = '0'
        
        # Get anchor date
        anchor_field, anchor_date = self.get_anchor_date(task)
        
        if not anchor_field or not anchor_date:
            sys.stderr.write("ERROR: Recurring task must have either 'due' or 'scheduled' date\n")
            sys.exit(1)
        
        task['ranchor'] = anchor_field
        
        # Process wait
        if 'wait' in task:
            wait_str = task['wait']
            ref_field, offset = self.parse_relative_date(wait_str)
            
            if ref_field and offset:
                task['rwait'] = wait_str
                del task['wait']
            else:
                wait_dt = self.parse_date(wait_str)
                if wait_dt and anchor_date:
                    delta_sec = int((anchor_date - wait_dt).total_seconds())
                    task['rwait'] = f'{anchor_field}-{delta_sec}s'
                    del task['wait']
        
        # Process scheduled
        if 'scheduled' in task and anchor_field != 'scheduled':
            sched_str = task['scheduled']
            ref_field, offset = self.parse_relative_date(sched_str)
            
            if ref_field and offset:
                task['rscheduled'] = sched_str
                del task['scheduled']
            else:
                sched_dt = self.parse_date(sched_str)
                if sched_dt and anchor_date:
                    delta_sec = int((anchor_date - sched_dt).total_seconds())
                    task['rscheduled'] = f'{anchor_field}-{delta_sec}s'
                    del task['scheduled']
        
        if DEBUG:
            debug_log(f"  Template created: status={task['status']}, rlast={task['rlast']}")
        
        return task
    
    def handle_template_modification(self, original, modified):
        """Handle modifications to a template"""
        if modified.get('status') in ['completed', 'deleted']:
            sys.stderr.write("ERROR: Cannot complete or delete a recurrence template.\n")
            sys.stderr.write("Delete the instances first, or modify the template instead.\n")
            sys.exit(1)
        
        # Normalize type if it was changed
        if 'type' in modified:
            modified['type'] = self.normalize_type(modified['type'])
        
        return modified
    
    def handle_instance_completion(self, original, modified):
        """Handle completion/deletion of an instance - spawn next instance"""
        if DEBUG:
            debug_log("=== handle_instance_completion called ===")
            debug_log(f"Original status: {original.get('status')}, Modified status: {modified.get('status')}")
            debug_log(f"Has rtemplate: {('rtemplate' in modified)}, Has rindex: {('rindex' in modified)}")
        
        # Only process if this is actually an instance being completed/deleted
        if 'rtemplate' not in modified or 'rindex' not in modified:
            if DEBUG:
                debug_log("Not an instance (missing rtemplate or rindex), skipping")
            return modified
        
        if modified.get('status') not in ['completed', 'deleted']:
            if DEBUG:
                debug_log(f"Status is {modified.get('status')}, not completed/deleted, skipping")
            return modified
        
        # Get template to spawn next instance
        template_uuid = modified.get('rtemplate')
        current_index = int(modified.get('rindex', 0))
        
        if DEBUG:
            debug_log(f"Processing instance completion: template={template_uuid}, index={current_index}")
        
        try:
            # Import spawning logic from on-exit
            import sys
            import os
            
            if DEBUG:
                debug_log("Attempting to import on-exit module...")
            
            # Get on-exit module path
            hook_dir = os.path.dirname(os.path.abspath(__file__))
            on_exit_path = os.path.join(hook_dir, 'on-exit_recurrence.py')
            
            if DEBUG:
                debug_log(f"Looking for on-exit at: {on_exit_path}")
                debug_log(f"File exists: {os.path.exists(on_exit_path)}")
            
            if os.path.exists(on_exit_path):
                # Import RecurrenceSpawner from on-exit
                import importlib.util
                
                if DEBUG:
                    debug_log("Creating module spec...")
                
                spec = importlib.util.spec_from_file_location("on_exit_recurrence", on_exit_path)
                on_exit_module = importlib.util.module_from_spec(spec)
                
                if DEBUG:
                    debug_log("Executing module...")
                
                spec.loader.exec_module(on_exit_module)
                
                if DEBUG:
                    debug_log("Module loaded, creating spawner...")
                
                # Create spawner and trigger next instance
                spawner = on_exit_module.RecurrenceSpawner()
                
                if DEBUG:
                    debug_log("Fetching template...")
                
                template = spawner.get_template(template_uuid)
                
                if template:
                    last_index = int(template.get('rlast', 0))
                    
                    if DEBUG:
                        debug_log(f"Template found, last_index={last_index}, current={current_index}")
                    
                    # Only spawn if this is the latest instance
                    if current_index >= last_index:
                        if DEBUG:
                            debug_log("This is latest instance, spawning next...")
                        
                        completion_time = None
                        if modified.get('status') == 'completed' and 'end' in modified:
                            from datetime import datetime
                            end_str = modified['end']
                            clean = str(end_str).replace('Z', '').replace('+00:00', '')
                            try:
                                completion_time = datetime.strptime(clean[:15], '%Y%m%dT%H%M%S')
                                if DEBUG:
                                    debug_log(f"Completion time: {completion_time}")
                            except Exception as e:
                                if DEBUG:
                                    debug_log(f"Could not parse completion time: {e}")
                        
                        # Spawn next instance
                        if DEBUG:
                            debug_log(f"Calling create_instance({template_uuid}, {current_index + 1}, {completion_time})")
                        
                        result = spawner.create_instance(template, current_index + 1, completion_time)
                        
                        if DEBUG:
                            debug_log(f"create_instance result: {result}")
                        
                        # Show messages if any
                        if modified.get('status') == 'deleted':
                            template_id = template.get('id', template.get('uuid'))
                            sys.stderr.write(
                                f"This is a recurring task. To delete all future instances "
                                f"enter 'task {template_id} delete'\n"
                            )
                            if DEBUG:
                                debug_log("Deletion message sent to stderr")
                    else:
                        if DEBUG:
                            debug_log(f"Not latest instance ({current_index} < {last_index}), skipping spawn")
                else:
                    if DEBUG:
                        debug_log("Template not found!")
            else:
                if DEBUG:
                    debug_log("on-exit file does not exist!")
        except Exception as e:
            if DEBUG:
                debug_log(f"EXCEPTION in handle_instance_completion: {type(e).__name__}: {e}")
                import traceback
                debug_log(f"Traceback: {traceback.format_exc()}")
            else:
                sys.stderr.write(f"Error spawning next instance: {e}\n")
        
        return modified


def main():
    """Main hook entry point"""
    if not lines:
        sys.exit(0)
    
    handler = RecurrenceHandler()
    
    if IS_ON_ADD:
        # On-add: single task input
        try:
            task = json.loads(lines[0])
        except json.JSONDecodeError as e:
            sys.stderr.write(f"Error parsing JSON: {e}\n")
            sys.exit(1)
        
        # Check if this should be a template
        if 'r' in task:
            task = handler.create_template(task)
            sys.stderr.write("Created recurrence template. First instance will be generated on exit.\n")
        
        print(json.dumps(task))
    
    else:
        # On-modify: two task inputs
        if len(lines) < 2:
            if lines:
                print(json.dumps(json.loads(lines[0])))
            sys.exit(0)
        
        try:
            original = json.loads(lines[0])
            modified = json.loads(lines[1])
        except json.JSONDecodeError as e:
            sys.stderr.write(f"Error parsing JSON: {e}\n")
            sys.exit(1)
        
        # Adding recurrence to existing task?
        if 'r' in modified and modified.get('status') != 'recurring':
            modified = handler.create_template(modified)
            sys.stderr.write("Created recurrence template. First instance will be generated on exit.\n")
        
        # Modifying a template?
        elif handler.is_template(original):
            modified = handler.handle_template_modification(original, modified)
        
        # Completing an instance?
        # NOTE: Instance completion is handled by on-exit hook, not on-modify!
        # The 'task done' command does NOT trigger on-modify, only on-exit.
        # This code path is kept for explicit 'task modify' commands that change status.
        elif handler.is_instance(original) and modified.get('status') in ['completed', 'deleted']:
            if DEBUG:
                debug_log(f"Instance status change detected (via modify command, not done)")
                debug_log(f"  Instance will be handled by on-exit hook")
        
        # Always output the modified task
        print(json.dumps(modified))
    
    if DEBUG:
        debug_log("Hook completed")
    
    sys.exit(0)


if __name__ == '__main__':
    main()
