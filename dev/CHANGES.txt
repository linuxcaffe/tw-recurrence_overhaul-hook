#!/bin/bash
# ============================================================================
# Taskwarrior Enhanced Recurrence - Test Suite
# Version: 0.3.3
# Last Updated: 2026-01-13
# Changes: Fixed ttask_count helper, disabled color codes in file output
# ============================================================================
#
# Usage:
#   test-recurrence.sh           # Output to terminal (with colors)
#   test-recurrence.sh -f        # Auto-generate dated filename (no colors)
#   test-recurrence.sh -f FILE   # Save to specific file (no colors)
#
# Directory structure:
#   ~/.task/hooks/recurrence/           # Main project
#   ~/.task/hooks/recurrence/test/      # Test outputs (auto-created)
#
# ============================================================================

# Detect script location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"  # Go up one level from test/
TEST_OUTPUT_DIR="$SCRIPT_DIR"

# Ensure test output directory exists
mkdir -p "$TEST_OUTPUT_DIR"

# Parse command line options
OUTPUT_FILE=""
AUTO_FILENAME=false
DEBUG_MODE=false

# Check for flags
for arg in "$@"; do
    if [ "$arg" = "-f" ]; then
        AUTO_FILENAME=true
        shift
        # If next arg exists and doesn't start with -, use it as filename
        if [ -n "$1" ] && [[ "$1" != -* ]]; then
            OUTPUT_FILE="$1"
            AUTO_FILENAME=false
        fi
    elif [ "$arg" = "-d" ]; then
        DEBUG_MODE=true
        shift
    fi
done

# Generate auto filename if requested
if [ "$AUTO_FILENAME" = true ]; then
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    COUNTER=1
    while [ -f "$TEST_OUTPUT_DIR/run-${TIMESTAMP}-$(printf "%03d" $COUNTER).txt" ]; do
        COUNTER=$((COUNTER + 1))
    done
    OUTPUT_FILE="$TEST_OUTPUT_DIR/run-${TIMESTAMP}-$(printf "%03d" $COUNTER).txt"
    echo "Auto-generated output file: $OUTPUT_FILE"
fi

# Redirect output to file if specified
if [ -n "$OUTPUT_FILE" ]; then
    # If not absolute path, make it relative to test output dir
    if [[ "$OUTPUT_FILE" != /* ]]; then
        OUTPUT_FILE="$TEST_OUTPUT_DIR/$OUTPUT_FILE"
    fi
    # Use tee with sed to strip ANSI color codes when writing to file
    exec > >(tee >(sed 's/\x1b\[[0-9;]*m//g' > "$OUTPUT_FILE"))
    exec 2>&1
    echo "Logging to: $OUTPUT_FILE"
    echo ""
fi

# Colors for output (always enabled for terminal, stripped from file by sed)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

# Test data location
TEST_DIR="/tmp/taskwarrior-recurrence-test-$$"
TEST_DATA="$TEST_DIR/data"
TEST_RC="$TEST_DIR/taskrc"

# ============================================================================
# Helper Functions
# ============================================================================

print_header() {
    echo -e "${BLUE}Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½Ã¢â€�ï¿½${NC}"
}

print_test() {
    echo -e "${YELLOW}[TEST]${NC} $1"
    TESTS_RUN=$((TESTS_RUN + 1))
}

print_pass() {
    echo -e "${GREEN}[PASS]${NC} $1"
    TESTS_PASSED=$((TESTS_PASSED + 1))
}

print_fail() {
    echo -e "${RED}[FAIL]${NC} $1"
    TESTS_FAILED=$((TESTS_FAILED + 1))
    
    # Show debug info if -d flag used
    if [ "$DEBUG_MODE" = true ]; then
        echo -e "${BLUE}[DEBUG]${NC} Additional context:"
        if [ -n "$2" ]; then
            echo "$2" | sed 's/^/  /'
        fi
    fi
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Task command with test configuration
ttask() {
    task rc:"$TEST_RC" rc.data.location="$TEST_DATA" "$@" 2>&1
}

# Task export with clean JSON (filters out TASKRC/TASKDATA override messages)
ttask_export() {
    ttask export "$@" | grep -v "^TASKRC" | grep -v "^TASKDATA" | grep -v "^Configuration"
}

# Task count with clean output (filters out override messages, returns just the number)
ttask_count() {
    ttask count "$@" | grep -v "^TASKRC" | grep -v "^TASKDATA" | grep -v "^Configuration" | tail -1
}

# Setup test environment
setup() {
    print_header "Setting up test environment"
    
    # Create test directory
    mkdir -p "$TEST_DATA/hooks"
    
    # Copy hooks from project directory (symlinks will be resolved)
    if [ -f "$PROJECT_DIR/on-add_recurrence.py" ]; then
        cp "$PROJECT_DIR/on-add_recurrence.py" "$TEST_DATA/hooks/"
        cp "$PROJECT_DIR/on-exit_recurrence.py" "$TEST_DATA/hooks/"
    elif [ -f ~/.task/hooks/on-add_recurrence.py ]; then
        cp ~/.task/hooks/on-add_recurrence.py "$TEST_DATA/hooks/"
        cp ~/.task/hooks/on-exit_recurrence.py "$TEST_DATA/hooks/"
    else
        echo -e "${RED}Error: Could not find hooks${NC}"
        exit 1
    fi
    
    chmod +x "$TEST_DATA/hooks/"*.py
    
    # Create on-modify symlink
    ln -sf on-add_recurrence.py "$TEST_DATA/hooks/on-modify_recurrence.py"
    
    # Copy recurrence.rc
    if [ -f "$PROJECT_DIR/recurrence.rc" ]; then
        cp "$PROJECT_DIR/recurrence.rc" "$TEST_DIR/recurrence.rc"
    elif [ -f ~/.task/hooks/recurrence/recurrence.rc ]; then
        cp ~/.task/hooks/recurrence/recurrence.rc "$TEST_DIR/recurrence.rc"
    else
        echo -e "${RED}Error: Could not find recurrence.rc${NC}"
        exit 1
    fi
    
    # Get versions
    local on_exit_ver=$(grep "^Version:" "$TEST_DATA/hooks/on-exit_recurrence.py" | head -1 | cut -d: -f2 | tr -d ' ')
    local on_add_ver=$(grep "^Version:" "$TEST_DATA/hooks/on-add_recurrence.py" | head -1 | cut -d: -f2 | tr -d ' ')
    
    # Create test taskrc
    cat > "$TEST_RC" <<EOF
data.location=$TEST_DATA
hooks.location=$TEST_DATA/hooks
hooks=on

# Include recurrence configuration
include $TEST_DIR/recurrence.rc

# Disable confirmation prompts
confirmation=no

# Export environment variables for hooks (Taskwarrior 2.6.2 method)
export.DEBUG_RECURRENCE=1
export.TASKRC=$TEST_RC
export.TASKDATA=$TEST_DATA
EOF

    # Also export for the test script itself
    export TASKRC="$TEST_RC"
    export TASKDATA="$TEST_DATA"
    export DEBUG_RECURRENCE=1
    
    # Initialize task database
    ttask version > /dev/null 2>&1
    
    print_info "Test directory: $TEST_DIR"
    print_info "Hooks: on-exit v$on_exit_ver, on-add v$on_add_ver"
    print_info "Debug mode: ENABLED"
    print_info "Tests will run in isolated environment"
}

# Cleanup test environment
cleanup() {
    print_header "Cleaning up"
    
    # Show hook log if debug mode and file exists
    if [ "$DEBUG_MODE" = true ] && [ -f "$TEST_DATA/recurrence_debug.log" ]; then
        echo -e "${BLUE}  [HOOK LOG]${NC}"
        tail -50 "$TEST_DATA/recurrence_debug.log" | sed 's/^/    /'
    fi
    
    if [ -d "$TEST_DIR" ]; then
        rm -rf "$TEST_DIR"
        print_info "Removed $TEST_DIR"
    fi
    
    # Unset environment variables
    unset TASKRC
    unset TASKDATA
    unset DEBUG_RECURRENCE
}

# Trap to ensure cleanup on exit
trap cleanup EXIT

# ============================================================================
# Test Functions
# ============================================================================

test_basic_template_creation() {
    print_test "Basic template creation"
    
    local output=$(ttask add "Basic test" r:1w due:tomorrow ty:p)
    
    if echo "$output" | grep -q "Created recurrence template"; then
        print_pass "Template created"
    else
        print_fail "Template not created"
        return
    fi
    
    # Check if instance was actually created by counting pending tasks
    local instance_count=$(ttask_count rtemplate.any: status:pending)
    if [ "$instance_count" -ge 1 ] 2>/dev/null; then
        print_pass "First instance created"
    else
        print_fail "First instance not created (count: $instance_count)"
        return
    fi
    
    # Verify rlast was updated
    local rlast=$(ttask_export status:recurring | jq -r '.[0].rlast' 2>/dev/null)
    if [ "$rlast" = "1" ]; then
        print_pass "Template rlast updated to 1"
    else
        print_fail "Template rlast is $rlast (expected 1)"
    fi
}

test_type_abbreviations() {
    print_test "Type abbreviations"
    
    local passed=0
    local failed=0
    
    # Test chained abbreviations
    for abbrev in c ch chai chained; do
        output=$(ttask add "Test $abbrev" r:1d due:today ty:$abbrev 2>&1)
        if echo "$output" | grep -q "Created recurrence template"; then
            ((passed++))
        else
            ((failed++))
        fi
    done
    
    # Test periodic abbreviations  
    for abbrev in p per periodic; do
        output=$(ttask add "Test $abbrev" r:1d due:today ty:$abbrev 2>&1)
        if echo "$output" | grep -q "Created recurrence template"; then
            ((passed++))
        else
            ((failed++))
        fi
    done
    
    if [ $failed -eq 0 ]; then
        print_pass "All abbreviations accepted ($passed/7)"
    else
        print_fail "Some abbreviations failed (passed: $passed, failed: $failed)"
    fi
}

test_chained_until_rejection() {
    print_test "Chained tasks reject 'until' dates"
    
    output=$(ttask add "Bad chained" r:1w due:tomorrow ty:c until:eom 2>&1 || true)
    
    if echo "$output" | grep -q "ERROR.*Chained recurrence cannot use 'until'"; then
        print_pass "Chained + until properly rejected"
    else
        print_fail "Chained + until should be rejected"
    fi
}

test_periodic_first_instance_due() {
    print_test "Periodic instance #1 matches template due date"
    
    ttask add "Due test" r:1mo due:2025-02-15 ty:p > /dev/null 2>&1
    
    local template_due=$(ttask_export status:recurring | jq -r '.[-1].due' 2>/dev/null)
    local template_uuid=$(ttask_export status:recurring | jq -r '.[-1].uuid' 2>/dev/null)
    
    if [ -z "$template_uuid" ] || [ "$template_uuid" = "null" ]; then
        print_fail "Could not find template"
        return
    fi
    
    local instance_due=$(ttask_export rtemplate:"$template_uuid" | jq -r '.[0].due' 2>/dev/null)
    
    if [ "$instance_due" = "$template_due" ]; then
        print_pass "Instance #1 due matches template"
    else
        print_fail "Instance due ($instance_due) != template ($template_due)"
    fi
}

test_chained_completion_spawns() {
    print_test "Chained task spawns on completion"
    
    ttask add "Chained test" r:1d due:today ty:c > /dev/null 2>&1
    
    local instance_id=$(ttask_export +RECURRING status:pending | jq -r '.[-1].id' 2>/dev/null)
    
    if [ -z "$instance_id" ] || [ "$instance_id" = "null" ]; then
        print_fail "No instance found"
        return
    fi
    
    ttask "$instance_id" done > /dev/null 2>&1
    
    local count=$(ttask_export +RECURRING status:pending | jq '. | length' 2>/dev/null)
    
    if [ "$count" -ge 1 ]; then
        print_pass "New instance created after completion"
    else
        print_fail "No new instance after completion"
    fi
}

test_periodic_until_preserved() {
    print_test "Periodic tasks preserve 'until' dates"
    
    ttask add "Until test" r:1w due:tomorrow ty:p until:2025-12-31 > /dev/null 2>&1
    
    local template_uuid=$(ttask_export status:recurring | jq -r '.[-1].uuid' 2>/dev/null)
    local instance_until=$(ttask_export rtemplate:"$template_uuid" | jq -r '.[0].until' 2>/dev/null)
    
    if echo "$instance_until" | grep -q "2025"; then
        print_pass "Instance preserves until date"
    else
        print_fail "Instance until not preserved (got: $instance_until)"
    fi
}

test_rlimit_pile_up() {
    print_test "rlimit maintains pending instance count"
    
    ttask add "Pile test" r:1w due:tomorrow ty:p rlimit:3 > /dev/null 2>&1
    
    local template_uuid=$(ttask_export status:recurring description:"Pile test" | jq -r '.[0].uuid' 2>/dev/null)
    
    if [ -z "$template_uuid" ] || [ "$template_uuid" = "null" ]; then
        print_fail "Could not find template"
        return
    fi
    
    # Initially should have 1 instance
    local count1=$(ttask_export rtemplate:"$template_uuid" status:pending | jq '. | length' 2>/dev/null)
    
    if [ "$count1" -eq 1 ]; then
        print_pass "rlimit:3 creates 1 instance initially"
    else
        print_fail "Expected 1 instance, got $count1"
        return
    fi
    
    # Complete instance #1
    local instance_id=$(ttask_export rtemplate:"$template_uuid" status:pending | jq -r '.[0].id' 2>/dev/null)
    ttask "$instance_id" done > /dev/null 2>&1
    
    # Now should have 3 instances
    local count2=$(ttask_export rtemplate:"$template_uuid" status:pending | jq '. | length' 2>/dev/null)
    
    if [ "$count2" -eq 3 ]; then
        print_pass "After completion, spawned to reach rlimit (3 pending)"
    else
        print_fail "Expected 3 instances, got $count2"
    fi
}

test_scheduled_anchor() {
    print_test "Scheduled-based recurrence (ranchor:scheduled)"
    
    ttask add "Scheduled test" r:1w scheduled:2025-03-01 ty:p > /dev/null 2>&1
    
    local template=$(ttask_export status:recurring | jq -r '.[-1]' 2>/dev/null)
    local ranchor=$(echo "$template" | jq -r '.ranchor' 2>/dev/null)
    
    if [ "$ranchor" = "scheduled" ]; then
        print_pass "Template uses scheduled anchor"
    else
        print_fail "Template ranchor is $ranchor (expected scheduled)"
        return
    fi
    
    # Check instance has scheduled field
    local template_uuid=$(echo "$template" | jq -r '.uuid')
    local instance_scheduled=$(ttask_export rtemplate:"$template_uuid" | jq -r '.[0].scheduled' 2>/dev/null)
    
    if [ -n "$instance_scheduled" ] && [ "$instance_scheduled" != "null" ]; then
        print_pass "Instance has scheduled date"
    else
        print_fail "Instance missing scheduled date"
    fi
}

test_relative_wait_dates() {
    print_test "Relative wait dates (wait:due-7d)"
    
    ttask add "Wait test" r:1mo due:2025-02-01 wait:due-7d ty:p > /dev/null 2>&1
    
    local instance=$(ttask_export +RECURRING status:waiting | jq -r '.[-1]' 2>/dev/null)
    local wait=$(echo "$instance" | jq -r '.wait' 2>/dev/null)
    
    if [ -n "$wait" ] && [ "$wait" != "null" ]; then
        print_pass "Relative wait date applied"
    else
        print_fail "Wait date not set"
    fi
}

test_recurring_tag_applied() {
    print_test "+RECURRING tag applied to instances"
    
    ttask add "Tag test" r:1w due:tomorrow ty:p > /dev/null 2>&1
    
    local count=$(ttask_export +RECURRING | jq '. | length' 2>/dev/null)
    
    # Handle empty/null count
    if [ -z "$count" ]; then
        count=0
    fi
    
    if [ "$count" -ge 1 ]; then
        print_pass "+RECURRING tag found"
    else
        print_fail "+RECURRING tag not applied (count: $count)"
    fi
}

test_template_modification() {
    print_test "Template modifications update correctly"
    
    ttask add "Mod test" r:1w due:tomorrow ty:p > /dev/null 2>&1
    
    local template_id=$(ttask_export status:recurring | jq -r '.[-1].id' 2>/dev/null)
    
    # Modify the template
    ttask "$template_id" modify r:2w > /dev/null 2>&1
    
    local new_r=$(ttask_export "$template_id" | jq -r '.[0].r' 2>/dev/null)
    
    if echo "$new_r" | grep -q "P14D"; then
        print_pass "Template period updated (1w Ã¢â€ â€™ 2w)"
    else
        print_fail "Template period not updated correctly (got: $new_r)"
    fi
}

test_chained_deletion_spawns() {
    print_test "Chained instance deletion spawns next"
    
    ttask add "Chain delete" r:1d due:today ty:c > /dev/null 2>&1
    
    local instance_id=$(ttask_export +RECURRING status:pending | jq -r '.[-1].id' 2>/dev/null)
    
    ttask "$instance_id" delete > /dev/null 2>&1
    
    local count=$(ttask_export +RECURRING status:pending | jq '. | length' 2>/dev/null)
    
    if [ "$count" -ge 1 ]; then
        print_pass "Chained deletion spawned next instance"
    else
        print_fail "Chained deletion did not spawn"
    fi
}

test_periodic_deletion_no_spawn() {
    print_test "Periodic instance deletion does NOT spawn"
    
    ttask add "Periodic delete" r:1d due:today ty:p > /dev/null 2>&1
    
    local template_uuid=$(ttask_export status:recurring | jq -r '.[-1].uuid' 2>/dev/null)
    local instance_id=$(ttask_export rtemplate:"$template_uuid" status:pending | jq -r '.[0].id' 2>/dev/null)
    
    ttask "$instance_id" delete > /dev/null 2>&1
    
    local count=$(ttask_export rtemplate:"$template_uuid" status:pending | jq '. | length' 2>/dev/null)
    
    if [ "$count" -eq 0 ]; then
        print_pass "Periodic deletion did not spawn"
    else
        print_fail "Periodic deletion spawned (got $count)"
    fi
}

test_rtemplates_report() {
    print_test "rtemplates report shows templates"
    
    ttask add "Report test" r:1w due:tomorrow ty:p > /dev/null 2>&1
    
    local output=$(ttask rtemplates 2>&1)
    
    if echo "$output" | grep -q "Report test"; then
        print_pass "rtemplates report working"
    else
        print_fail "rtemplates report not working"
    fi
}

# ============================================================================
# Main Test Runner
# ============================================================================

main() {
    print_header "Taskwarrior Enhanced Recurrence - Test Suite v0.3.0"
    
    # Check dependencies
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required for tests${NC}"
        echo "Install with: sudo apt install jq"
        exit 1
    fi
    
    if ! command -v task &> /dev/null; then
        echo -e "${RED}Error: taskwarrior is required${NC}"
        exit 1
    fi
    
    # Setup
    setup
    
    # Run tests
    print_header "Running Tests"
    
    test_basic_template_creation
    test_type_abbreviations
    test_chained_until_rejection
    test_periodic_first_instance_due
    test_chained_completion_spawns
    test_periodic_until_preserved
    test_rlimit_pile_up
    test_scheduled_anchor
    test_relative_wait_dates
    test_recurring_tag_applied
    test_template_modification
    test_chained_deletion_spawns
    test_periodic_deletion_no_spawn
    test_rtemplates_report
    
    # Summary
    print_header "Test Summary"
    echo -e "Total tests:  ${BLUE}$TESTS_RUN${NC}"
    echo -e "Passed:       ${GREEN}$TESTS_PASSED${NC}"
    echo -e "Failed:       ${RED}$TESTS_FAILED${NC}"
    
    if [ -n "$OUTPUT_FILE" ]; then
        echo -e "\nResults saved to: ${BLUE}$OUTPUT_FILE${NC}"
    fi
    
    if [ $TESTS_FAILED -eq 0 ]; then
        echo -e "\n${GREEN}Ã¢Å“â€œ All tests passed!${NC}\n"
        exit 0
    else
        echo -e "\n${RED}Ã¢Å“â€” Some tests failed${NC}\n"
        exit 1
    fi
}

# Run main
main "$@"
